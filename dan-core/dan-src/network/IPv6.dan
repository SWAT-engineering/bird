module network::IPv6

struct IPv6Header {
    u32 versionClassFlow ?((this >>> (32 - 4)) == 6) 
    u16 payloadLength
    u8 nextHeader
    u8 hopLimit
    u128 srcAddress
    u128 dstAddress
    IPV6ExtensionHeader extension(payloadLength, nextHeader)

    int dataSize = extension.remainingDataSize
    u8 protocol = extension.protocol
}

choice IPV6ExtensionHeaderChain(int remainingSize, u8 nextHeader) {
    abstract int remainingDataSize
    abstract u8 protocol
    
    HopByHopOptions(remainingDataSize, previousNextHeader)
    Routing(remainingDataSize, previousNextHeader)
    Fragment(remainingDataSize, previousNextHeader)
    
    struct { // Terminating the chain, parse nothing more
        int remainingDataSize = remainingDataSize
        u8 protocol = nextHeader
    }
}

struct HopByHopOptions(int remainingSize, u8 previousNextHeader) {
    u8 nextHeader ?(previousNextHeader == 0)
    u8 optionsLength
    u8[] options[6 + optionsLength]
    
    IPV6ExtensionHeaderChain next(remainingSize - (8 + optionsLength), nextHeader)
}


struct Routing(int remainingSize, u8 previousNextHeader) {
    u8 nextHeader ?(previousNextHeader == 43)
    u8 dataLength
    u8 routingType
    u8 segementsLeft
    u8[] typeSpecificData[4 + dataLength]

    IPV6ExtensionHeaderChain next(remainingSize - (8 + dataLength), nextHeader)
}

struct Fragment(int remainingSize, u8 previousNextHeader) {
    u8 nextHeader ?(previousNextHeader == 44)
    u8 _
    u16 fragmentOffset
    int actualFragmentOffset = fragmentOffset >>> 3
    bool lastFragment = actualFragmentOffset & 0b1 == 0b0

    u32 identification

    IPV6ExtensionHeaderChain next(remainingSize - 8, nextHeader)
}
